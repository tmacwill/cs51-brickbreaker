package brickBreaker;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;


/**
 * Creates a panel that controls and displays game play.
 * 
 * @author Jacob Pritt
 * @version 4/30/10
 * @file GamePanel.java
 */
public class GamePanel extends PRPanel implements ActionListener, KeyListener
{
    public static final int PWIDTH = 1000;  // Size of panel
    public static final int PHEIGHT = 700;
    public static final int BORDER = 10;
    public static final int ARENA_WIDTH = PWIDTH - 2*BORDER;
    public static final int ARENA_HEIGHT = PHEIGHT - 2*BORDER;
    
    private static final String GAMEOVER = "GAME OVER";
    private static final String WIN = "YOU WIN";
    private static String MESSAGE = "";
    
    private static final int delay = 10; // milliseconds
    private javax.swing.Timer clock;
    private boolean running  = false;   // stops the animation
    private volatile boolean isPaused = false;
    private volatile boolean gameOver = false;  // for game termination
    
    private Graphics dbg;
    private Image dbImage = null;
    
    private Start main;
    private LevelPlayer levelPlayer;
    private int totalScore;

    /**
     * GamePanel constructor.
     * @param lev Level object containing the components to be used in this game
     * @param main The main Start object used to flip panels when the game is over
     */
    public GamePanel(Level lev, Start main)
    {
        setBackground(Color.white);
        setPreferredSize(new Dimension(PWIDTH, PHEIGHT));
        
        this.main = main;
        levelPlayer = new LevelPlayer(lev);
    } 

    /**
     * Resets the game to its initial state.
     * @param lev Level object containing all the initial components in this game
     */
    public void reset (Level lev)
    {
        levelPlayer = new LevelPlayer(lev);
    }
    
    /* Wait for the JPanel to be added to the
     * JFrame before starting.    */
    public void init()
    {
        super.addNotify();  // creates the peer
    }
    
    /**
     * Resets the ball position and score to zero and starts the clock.
     */
    public void start()
    {
        Ball.resetVars();
        totalScore = 0;
        if (clock == null) 
            clock = new javax.swing.Timer(delay,this);
        isPaused = false;
        gameOver = false;
        running = true;
        clock.start();
        
        gameRender();
        paintScreen();
    }
    
    /**
     * Stops gameplay
     */
    public void stop()
    {   
        running = false;
        gameOver = true;
        clock.stop();
    }

    /**
     * Pauses gameplay.  The clock continues running and painting the screen, but game components are not updated.
     */
    public void pause()
    {   isPaused = true;    }

    /**
     * Resumes gameplay
     */
    public void resume()
    {   isPaused = false;   }
    
    /**
     * Repeatedly update, render and sleep.  This method is automatically called every time the timer updates.
     * @param e ActionEvent generated by the timer.
     */
    public void actionPerformed (ActionEvent e)
    {
        if (running) {
            gameUpdate();
            gameRender();
            paintScreen();
        }
    }

    /**
     * Updates the game components and checks if the game has been won or lost.
     */
    private void gameUpdate()
    {
        if (!isPaused && !gameOver) {
            totalScore += levelPlayer.update();
            if (!levelPlayer.ballsInBounds()) {
                gameOver = true;
                MESSAGE = GAMEOVER;
                stop();
                gameRender();
                paintScreen();
                try {
                    Thread.sleep(1000);
                }
                catch (Exception e) {
                    main.endGame(levelPlayer.getLevel(), totalScore);
                }
                main.endGame(levelPlayer.getLevel(), totalScore);
            }
            if (levelPlayer.cleared()) {
                gameOver = true;
                MESSAGE = WIN;
                gameRender();
                paintScreen();
                try {
                    Thread.sleep(1000);
                }
                catch (Exception e) {
                    main.endGame(levelPlayer.getLevel(), totalScore);
                }
                main.endGame(levelPlayer.getLevel(), totalScore);
            }
        }
    }

    /**
     * Issues a call to all game components to draw themselves on an image.
     * Method paintScreen() then paints this image to the screen, elminating flickering.
     */
    private void gameRender()
    {
        if (dbImage == null) {  // create the buffer
            dbImage = createImage(PWIDTH, PHEIGHT);
            if (dbImage == null) {
                System.out.println("dbImage is null");
                return;
            }
            else
                dbg = dbImage.getGraphics();
        }
        
        // clear the background
        dbg.setColor(Color.white);
        dbg.fillRect(0, 0, PWIDTH, PHEIGHT);
        
        // Draws a thick black border around the playing arena
        dbg.setColor(Color.black);
        dbg.drawRect(BORDER,BORDER, PWIDTH-2*BORDER, PHEIGHT-2*BORDER);
        dbg.drawRect(BORDER-1,BORDER-1, PWIDTH-2*BORDER+2, PHEIGHT-2*BORDER+2);
        dbg.drawRect(BORDER-2,BORDER-2, PWIDTH-2*BORDER+4, PHEIGHT-2*BORDER+4);
        
        levelPlayer.drawComponents(dbg);
        
        dbg.setColor(Color.blue);
        dbg.setFont(new Font("Arial", Font.BOLD, 20));
        dbg.drawString( Integer.toString(totalScore), PWIDTH-100, BORDER+20);
        
        if (gameOver)
            gameOverMessage(dbg);
    }   // end of gameRender()
    
    /**
     * Actively renders the buffer image to the screen.
     */
    private void paintScreen()
    {
        Graphics g;
        try {
            g = getGraphics();  // get panel's graphic content
            if ((g != null) && (dbImage != null))
                g.drawImage(dbImage, 0, 0, null);
            Toolkit.getDefaultToolkit().sync();     // sync the display on some systems
            g.dispose();
        }
        catch (Exception e)
        {   //System.out.println("GamePanel: Graphics context error: " + e); 
        }
    }   // end of paintScreen()
    
    /**
     * Prints the game-over message on the screen.
     * @param g The Graphics object with which to draw.
     */
    private void gameOverMessage(Graphics g)
    {   
        int x = (int)(PWIDTH/2 - 100);
        int y = (int)(PHEIGHT/2 + 50);
        g.drawString (MESSAGE, x, y);
    }
    
    /**
     * Processes the key event, either leaving the game or moving a racket.
     * @param e Generate KeyEvent corresponding to the key that has been pressed.
     */
    public void keyPressed(KeyEvent e)
    {
        if (running) {
            int code = e.getKeyCode();
            if (code == KeyEvent.VK_F1 || code == KeyEvent.VK_F2)
                start();
            else if (code == KeyEvent.VK_ESCAPE)
                main.endGame(levelPlayer.getLevel(), 0);
            else
                levelPlayer.keyPressed(code);
        }
    }

    /**
     * Passes the key event on to the level player, which stops the corresponding racket from moving.
     * @param e Generate KeyEvent corresponding to the key that has been pressed.
     */
    public void keyReleased(KeyEvent e)
    {
        if (running) {
            int code = e.getKeyCode();
            levelPlayer.keyReleased(code);
        }
    }

    /**
     * Takes no action.
     * @param e Generate KeyEvent corresponding to the key that has been pressed.
     */
    public void keyTyped(KeyEvent e) { }
}